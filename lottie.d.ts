/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type HttpsLottiefilesGithubIoLottieDocsSchemaLottieSchemaJson =
  Animation;
/**
 * Top level object, describing the animation
 */
export type Animation = VisualObject & {
  v?: Version;
  fr: Framerate;
  ip: InPoint;
  op: OutPoint;
  w: Width;
  h: Height;
  ddd?: Threedimensional;
  assets?: Assets;
  comps?: ExtraCompositions;
  fonts?: Fonts;
  chars?: Characters2;
  meta?: Metadata;
  metadata?: UserMetadata;
  markers?: Markers;
  mb?: MotionBlur1;
  slots?: Slots;
  [k: string]: unknown;
} & Composition;
export type VisualObject = {
  nm?: Name;
  mn?: MatchName;
  [k: string]: unknown;
};
/**
 * Name, as seen from editors and the like
 */
export type Name = string;
/**
 * Match name, used in expressions
 */
export type MatchName = string;
export type Version = string;
/**
 * Framerate in frames per second
 */
export type Framerate = number;
/**
 * "In Point", which frame the animation starts at (usually 0)
 */
export type InPoint = number;
/**
 * "Out Point", which frame the animation stops/loops at, which makes this the duration in frames when `ip` is 0
 */
export type OutPoint = number;
/**
 * Width of the animation
 */
export type Width = number;
/**
 * Height of the animation
 */
export type Height = number;
/**
 * Whether the animation has 3D layers
 */
export type Threedimensional = Threedimensional1 & Threedimensional2;
export type Threedimensional1 = True | False;
export type True = 1;
export type False = 0;
export type Threedimensional2 = 0 | 1;
/**
 * External image
 */
export type Image = FileAsset & {
  w?: Width1;
  h?: Height1;
  t?: Type;
  sid?: SlotID;
  [k: string]: unknown;
};
/**
 * Asset referencing a file
 */
export type FileAsset = Asset & {
  u?: Path;
  p: FileName;
  e?: Embedded;
  [k: string]: unknown;
};
export type Asset = {
  id: ID;
  nm?: Name1;
  [k: string]: unknown;
};
/**
 * Unique identifier used by layers when referencing this asset
 */
export type ID = string;
/**
 * Human readable name
 */
export type Name1 = string;
/**
 * Path to the directory containing a file
 */
export type Path = string;
/**
 * Filename or data url
 */
export type FileName = string;
/**
 * Whether the file is embedded
 */
export type Embedded = Embedded1 & Embedded2;
export type Embedded1 = True | False;
export type Embedded2 = 0 | 1;
/**
 * Width of the image
 */
export type Width1 = number;
/**
 * Height of the image
 */
export type Height1 = number;
/**
 * Marks as part of an image sequence if present
 */
export type Type = "seq";
/**
 * One of the ID in the file's slots
 */
export type SlotID = string;
/**
 * Asset containing an animation that can be referenced by layers.
 */
export type Precomposition = Asset &
  Composition & {
    fr?: Framerate1;
    xt?: Extra;
    [k: string]: unknown;
  };
/**
 * Layer that renders a Precomposition asset
 */
export type PrecompositionLayer = VisualLayer & {
  ty: Type40;
  refId: ReferenceId;
  w: Width2;
  h: Height2;
  tm?: TimeRemapping;
  [k: string]: unknown;
};
/**
 * Layer used to affect visual elements
 */
export type VisualLayer = Layer & {
  ks: Transform;
  ao?: AutoOrient;
  tt?: MatteMode;
  tp?: MatteParent;
  td?: MatteTarget;
  hasMask?: HasMasks;
  masksProperties?: Masks;
  ef?: Effects;
  mb?: MotionBlur;
  sy?: LayerStyle;
  bm?: BlendMode7;
  cl?: CSSClass;
  ln?: LayerXMLID;
  tg?: LayerXMLTagName;
  cp?: CollapseTransform;
  ct?: CollapseTransform1;
  [k: string]: unknown;
};
export type Layer = VisualObject & {
  ddd?: Threedimensional3;
  hd?: Hidden;
  ty: Type1;
  ind?: Index;
  parent?: ParentIndex;
  sr?: TimeStretch;
  ip: InPoint1;
  op: OutPoint1;
  st: StartTime;
  [k: string]: unknown;
};
/**
 * Whether the layer is threedimensional
 */
export type Threedimensional3 = Threedimensional4 & Threedimensional5;
export type Threedimensional4 = True | False;
export type Threedimensional5 = 0 | 1;
/**
 * Whether the layer is hidden
 */
export type Hidden = boolean;
/**
 * Layer Type
 */
export type Type1 = Type2 & Type3;
export type Type2 = number;
export type Type3 =
  | PrecompositionLayer1
  | SolidColorLayer
  | ImageLayer
  | NullLayer
  | ShapeLayer
  | TextLayer
  | AudioLayer
  | VideoPlaceholder
  | ImageSequence
  | VideoLayer
  | ImagePlaceholder
  | GuideLayer
  | AdjustmentLayer
  | Camera
  | LightLayer
  | DataLayer;
export type PrecompositionLayer1 = 0;
export type SolidColorLayer = 1;
export type ImageLayer = 2;
export type NullLayer = 3;
export type ShapeLayer = 4;
export type TextLayer = 5;
export type AudioLayer = 6;
export type VideoPlaceholder = 7;
export type ImageSequence = 8;
export type VideoLayer = 9;
export type ImagePlaceholder = 10;
export type GuideLayer = 11;
export type AdjustmentLayer = 12;
export type Camera = 13;
export type LightLayer = 14;
export type DataLayer = 15;
/**
 * Index that can be used for parenting and referenced in expressions
 */
export type Index = number;
/**
 * Must be the `ind` property of another layer
 */
export type ParentIndex = number;
export type TimeStretch = number;
/**
 * Frame when the layer becomes visible
 */
export type InPoint1 = number;
/**
 * Frame when the layer becomes invisible
 */
export type OutPoint1 = number;
export type StartTime = number;
/**
 * Layer transform
 */
export type Transform = {
  a?: AnchorPoint;
  s?: Scale;
  o?: Opacity;
  sk?: Skew;
  sa?: SkewAxis;
  [k: string]: unknown;
} & (
  | (
      | {
          p?: Position;
          [k: string]: unknown;
        }
      | {
          p?: Position1;
          [k: string]: unknown;
        }
    )
  | (
      | {
          r?: Rotation;
          [k: string]: unknown;
        }
      | {
          rx?: XRotation;
          ry?: YRotation;
          rz?: ZRotation;
          or?: Orientation;
          [k: string]: unknown;
        }
    )
);
/**
 * Anchor point: a position (relative to its parent) around which transformations are applied (ie: center for rotation / scale)
 */
export type AnchorPoint = {
  ix?: PropertyIndex;
  a?: Animated;
  x?: Expression;
  l?: Length;
  [k: string]: unknown;
} & {
  [k: string]: unknown;
};
export type PropertyIndex = number;
/**
 * Whether the property is animated
 */
export type Animated = Animated1 & Animated2;
export type Animated1 = True | False;
export type Animated2 = 0 | 1;
export type Expression = string;
/**
 * Number of components in the value arrays.
 * If present values will be truncated or expanded to match this length when accessed from expressions.
 */
export type Length = number;
/**
 * Scale factor, `[100, 100]` for no scaling
 */
export type Scale = AnimatedProperty & {
  l?: Length1;
  [k: string]: unknown;
};
/**
 * An animatable property that holds an array of numbers
 */
export type AnimatedProperty = {
  ix?: PropertyIndex1;
  a?: Animated3;
  x?: Expression1;
  sid?: SlotID1;
  [k: string]: unknown;
} & {
  [k: string]: unknown;
};
export type PropertyIndex1 = number;
/**
 * Whether the property is animated
 */
export type Animated3 = Animated4 & Animated5;
export type Animated4 = True | False;
export type Animated5 = 0 | 1;
export type Expression1 = string;
/**
 * One of the ID in the file's slots
 */
export type SlotID1 = string;
/**
 * Number of components in the value arrays.
 * If present values will be truncated or expanded to match this length when accessed from expressions.
 */
export type Length1 = number;
/**
 * An animatable property that holds a float
 */
export type Opacity = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Skew amount as an angle in degrees
 */
export type Skew = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Direction along which skew is applied, in degrees (`0` skews along the X axis, `90` along the Y axis)
 */
export type SkewAxis = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Position / Translation
 */
export type Position = {
  ix?: PropertyIndex;
  a?: Animated;
  x?: Expression;
  l?: Length;
  [k: string]: unknown;
} & {
  [k: string]: unknown;
};
export type Split = true;
/**
 * An animatable property that holds a float
 */
export type X = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Y = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Z = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Rotation in degrees, clockwise
 */
export type Rotation = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Split rotation component
 */
export type XRotation = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Split rotation component
 */
export type YRotation = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Split rotation component, equivalent to `r` when not split
 */
export type ZRotation = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds an array of numbers
 */
export type Orientation = AnimatedProperty & {
  l?: Length1;
  [k: string]: unknown;
};
/**
 * If 1, The layer will rotate itself to match its animated position path
 */
export type AutoOrient = AutoOrient1 & AutoOrient2;
export type AutoOrient1 = True | False;
export type AutoOrient2 = 0 | 1;
/**
 * Defines the track matte mode for the layer
 */
export type MatteMode = MatteMode1 & MatteMode2;
export type MatteMode1 = number;
export type MatteMode2 = Normal | Alpha | InvertedAlpha | Luma | InvertedLuma;
export type Normal = 0;
export type Alpha = 1;
export type InvertedAlpha = 2;
export type Luma = 3;
export type InvertedLuma = 4;
/**
 * Index of the layer used as matte, if omitted assume the layer above the current one
 */
export type MatteParent = number;
/**
 * If set to 1, it means a layer is using this layer as a track matte
 */
export type MatteTarget = MatteTarget1 & MatteTarget2;
export type MatteTarget1 = True | False;
export type MatteTarget2 = 0 | 1;
/**
 * Whether the layer has masks applied
 */
export type HasMasks = boolean;
/**
 * Bezier shape used to mask/clip a layer
 */
export type Mask = VisualObject & {
  inv?: Inverted;
  pt?: Shape;
  o?: Opacity1;
  mode?: Mode;
  x?: Expand;
  [k: string]: unknown;
};
export type Inverted = boolean;
/**
 * An animatable property that holds a Bezier
 */
export type Shape = {
  ix?: PropertyIndex2;
  a?: Animated6;
  x?: Expression2;
  [k: string]: unknown;
} & {
  [k: string]: unknown;
};
export type PropertyIndex2 = number;
/**
 * Whether the property is animated
 */
export type Animated6 = Animated7 & Animated8;
export type Animated7 = True | False;
export type Animated8 = 0 | 1;
export type Expression2 = string;
/**
 * An animatable property that holds a float
 */
export type Opacity1 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * How masks interact with each other. See https://helpx.adobe.com/after-effects/using/alpha-channels-masks-mattes.html
 */
export type Mode = Mode1 & Mode2;
export type Mode1 =
  | None
  | Add
  | Subtract
  | Intersect
  | Lighten
  | Darken
  | Difference;
export type None = "n";
export type Add = "a";
export type Subtract = "s";
export type Intersect = "i";
export type Lighten = "l";
export type Darken = "d";
export type Difference = "f";
export type Mode2 = string;
/**
 * An animatable property that holds a float
 */
export type Expand = AnimatedProperty & {
  [k: string]: unknown;
};
export type Masks = Mask[];
/**
 * Some lottie files use `ty` = 5 for many different effects
 */
export type CustomEffect = Effect & {
  ty: Type14;
  [k: string]: unknown;
};
/**
 * Layer effect
 */
export type Effect = VisualObject & {
  ef: EffectValues;
  np?: PropertyCount;
  ix?: EffectIndex1;
  ty: Type13;
  en?: Enabled;
  [k: string]: unknown;
};
export type EffectValueAngle = EffectValue & {
  ty: Type5;
  v?: Value;
  [k: string]: unknown;
};
/**
 * Value for an effect
 */
export type EffectValue = VisualObject & {
  ix?: EffectIndex;
  mn?: MatchName1;
  nm?: Name2;
  ty?: Type4;
  [k: string]: unknown;
};
export type EffectIndex = number;
export type MatchName1 = string;
export type Name2 = string;
export type Type4 = number;
export type Type5 = 1;
/**
 * An animatable property that holds a float
 */
export type Value = AnimatedProperty & {
  [k: string]: unknown;
};
export type EffectValueCheckbox = EffectValue & {
  ty: Type6;
  v?: Value1;
  [k: string]: unknown;
};
export type Type6 = 4;
/**
 * An animatable property that holds a float
 */
export type Value1 = AnimatedProperty & {
  [k: string]: unknown;
};
export type EffectValueColor = EffectValue & {
  ty: Type7;
  v?: Value2;
  [k: string]: unknown;
};
export type Type7 = 2;
/**
 * An animatable property that holds a Color
 */
export type Value2 = AnimatedProperty & {
  [k: string]: unknown;
};
export type EffectValueDropDown = EffectValue & {
  ty: Type8;
  v?: Value3;
  [k: string]: unknown;
};
export type Type8 = 7;
/**
 * An animatable property that holds a float
 */
export type Value3 = AnimatedProperty & {
  [k: string]: unknown;
};
export type IgnoredValue = EffectValue & {
  ty: Type9;
  v?: Value4;
  [k: string]: unknown;
};
export type Type9 = 6;
export type Value4 = number;
export type EffectValueLayer = EffectValue & {
  ty: Type10;
  v?: Value5;
  [k: string]: unknown;
};
export type Type10 = 10;
/**
 * An animatable property that holds a float
 */
export type Value5 = AnimatedProperty & {
  [k: string]: unknown;
};
export type EffectValuePoint = EffectValue & {
  ty: Type11;
  v?: Value6;
  [k: string]: unknown;
};
export type Type11 = 3;
/**
 * An animatable property that holds an array of numbers
 */
export type Value6 = AnimatedProperty & {
  l?: Length1;
  [k: string]: unknown;
};
export type EffectValueSlider = EffectValue & {
  ty: Type12;
  v?: Value7;
  [k: string]: unknown;
};
export type Type12 = 0;
/**
 * An animatable property that holds a float
 */
export type Value7 = AnimatedProperty & {
  [k: string]: unknown;
};
export type EffectValues = (
  | EffectNoValue
  | EffectValueAngle
  | EffectValueCheckbox
  | EffectValueColor
  | EffectValueDropDown
  | IgnoredValue
  | EffectValueLayer
  | EffectValuePoint
  | EffectValueSlider
)[];
/**
 * Number of values in `ef`
 */
export type PropertyCount = number;
export type EffectIndex1 = number;
/**
 * Effect type
 */
export type Type13 = number;
/**
 * Represents boolean values as an integer. 0 is false, 1 is true.
 */
export type Enabled = Enabled1 & Enabled2;
export type Enabled1 = True | False;
export type Enabled2 = 0 | 1;
export type Type14 = 5;
/**
 * Adds a shadow to the layer
 */
export type DropShadowEffect = Effect & {
  ty: Type15;
  ef?: EffectValues1;
  [k: string]: unknown;
};
export type Type15 = 25;
export type EffectValues1 = unknown[];
/**
 * Replaces the whole layer with the given color
 */
export type FillEffect = Effect & {
  ty: Type16;
  ef?: EffectValues2;
  [k: string]: unknown;
};
export type Type16 = 21;
export type EffectValues2 = unknown[];
/**
 * Gaussian blur
 */
export type GaussianBlurEffect = Effect & {
  ty: Type17;
  ef?: EffectValues3;
  [k: string]: unknown;
};
export type Type17 = 29;
export type EffectValues3 = unknown[];
/**
 * Uses a layer as a mask
 */
export type SetMatteEffect = Effect & {
  ty: Type18;
  ef?: EffectValues4;
  [k: string]: unknown;
};
export type Type18 = 28;
export type EffectValues4 = unknown[];
export type ProLevelsEffect = Effect & {
  ty: Type19;
  ef?: EffectValues5;
  [k: string]: unknown;
};
export type Type19 = 24;
export type EffectValues5 = unknown[];
export type StrokeEffect = Effect & {
  ty: Type20;
  ef?: EffectValues6;
  [k: string]: unknown;
};
export type Type20 = 22;
export type EffectValues6 = unknown[];
/**
 * Colorizes the layer
 */
export type TintEffect = Effect & {
  ty: Type21;
  ef?: EffectValues7;
  [k: string]: unknown;
};
export type Type21 = 20;
export type EffectValues7 = unknown[];
/**
 * Maps layers colors based on bright/mid/dark colors
 */
export type TritoneEffect = Effect & {
  ty: Type22;
  ef?: EffectValues8;
  [k: string]: unknown;
};
export type Type22 = 23;
export type EffectValues8 = unknown[];
export type RadialWipe = Effect & {
  ty: Type23;
  ef?: EffectValues9;
  [k: string]: unknown;
};
export type Type23 = 26;
export type EffectValues9 = unknown[];
export type WavyEffect = Effect & {
  ty: Type24;
  ef: EffectValues10;
  [k: string]: unknown;
};
export type Type24 = 32;
export type EffectValues10 = unknown[];
export type PuppetEffect = Effect & {
  ty: Type25;
  ef: EffectValues11;
  [k: string]: unknown;
};
export type Type25 = 34;
export type EffectValues11 = unknown[];
export type SpherizeEffect = Effect & {
  ty: Type26;
  ef?: EffectValues12;
  [k: string]: unknown;
};
export type Type26 = 33;
export type EffectValues12 = unknown[];
export type MeshWarpEffect = Effect & {
  ty: Type27;
  ef: EffectValues13;
  [k: string]: unknown;
};
export type Type27 = 31;
export type EffectValues13 = unknown[];
export type DisplacementMapEffect = Effect & {
  ty: Type28;
  ef: EffectValues14;
  [k: string]: unknown;
};
export type Type28 = 27;
export type EffectValues14 = unknown[];
export type TwirlEffect = Effect & {
  ty: Type29;
  ef: EffectValues15;
  [k: string]: unknown;
};
export type Type29 = 30;
export type EffectValues15 = unknown[];
/**
 * List of layer effects
 */
export type Effects = (
  | CustomEffect
  | DropShadowEffect
  | FillEffect
  | GaussianBlurEffect
  | SetMatteEffect
  | ProLevelsEffect
  | StrokeEffect
  | TintEffect
  | TritoneEffect
  | RadialWipe
  | WavyEffect
  | PuppetEffect
  | SpherizeEffect
  | MeshWarpEffect
  | DisplacementMapEffect
  | TwirlEffect
)[];
/**
 * Whether motion blur is enabled for the layer
 */
export type MotionBlur = boolean;
/**
 * Stroke / frame
 */
export type LayerStroke = LayerStyle1 & {
  ty: Type31;
  s?: Size;
  c?: Color;
  [k: string]: unknown;
};
/**
 * Style applied to a layer
 */
export type LayerStyle1 = VisualObject & {
  ty: Type30;
  [k: string]: unknown;
};
/**
 * Style Type
 */
export type Type30 = number;
/**
 * Layer Type
 */
export type Type31 = 0;
/**
 * An animatable property that holds a float
 */
export type Size = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a Color
 */
export type Color = AnimatedProperty & {
  [k: string]: unknown;
};
export type DropShadow = LayerStyle1 & {
  ty: Type32;
  c?: Color1;
  o?: Opacity2;
  a?: Angle;
  s?: Size1;
  d?: Distance;
  ch?: ChokeSpread;
  bm?: BlendMode;
  no?: Noise;
  lc?: LayerConceal;
  [k: string]: unknown;
};
/**
 * Layer Type
 */
export type Type32 = 1;
/**
 * An animatable property that holds a Color
 */
export type Color1 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Opacity2 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Local light angle
 */
export type Angle = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Blur size
 */
export type Size1 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Distance = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type ChokeSpread = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type BlendMode = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Noise = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Layer knowck out drop shadow
 */
export type LayerConceal = AnimatedProperty & {
  [k: string]: unknown;
};
export type InnerShadow = LayerStyle1 & {
  ty: Type33;
  c?: Color2;
  o?: Opacity3;
  a?: Angle1;
  s?: Size2;
  d?: Distance1;
  ch?: ChokeSpread1;
  bm?: BlendMode1;
  no?: Noise1;
  [k: string]: unknown;
};
/**
 * Layer Type
 */
export type Type33 = 2;
/**
 * An animatable property that holds a Color
 */
export type Color2 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Opacity3 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Local light angle
 */
export type Angle1 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Blur size
 */
export type Size2 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Distance1 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type ChokeSpread1 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type BlendMode1 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Noise1 = AnimatedProperty & {
  [k: string]: unknown;
};
export type OuterGlow = LayerStyle1 & {
  ty: Type34;
  c?: Color3;
  o?: Opacity4;
  r?: Range;
  ch?: ChokeSpread2;
  bm?: BlendMode2;
  no?: Noise2;
  j?: Jitter;
  [k: string]: unknown;
};
/**
 * Layer Type
 */
export type Type34 = 3;
/**
 * An animatable property that holds a Color
 */
export type Color3 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Opacity4 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Range = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type ChokeSpread2 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type BlendMode2 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Noise2 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Jitter = AnimatedProperty & {
  [k: string]: unknown;
};
export type InnerGlow = LayerStyle1 & {
  ty: Type35;
  c?: Color4;
  o?: Opacity5;
  r?: Range1;
  sr?: Source;
  ch?: ChokeSpread3;
  bm?: BlendMode3;
  no?: Noise3;
  j?: Jitter1;
  [k: string]: unknown;
};
/**
 * Layer Type
 */
export type Type35 = 4;
/**
 * An animatable property that holds a Color
 */
export type Color4 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Opacity5 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Range1 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Source = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type ChokeSpread3 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type BlendMode3 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Noise3 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Jitter1 = AnimatedProperty & {
  [k: string]: unknown;
};
export type BevelEmboss = LayerStyle1 & {
  ty: Type36;
  bs?: BevelStyle;
  bt?: Technique;
  sr?: Strength;
  s?: Size3;
  sf?: Soften;
  ga?: GlobalAngle;
  a?: Angle2;
  ll?: Altitude;
  hm?: HighlightMode;
  hc?: HighlightColor;
  ho?: HighlightOpacity;
  sm?: ShadowMode;
  sc?: ShadowColor;
  so?: ShadowOpacity;
  [k: string]: unknown;
};
/**
 * Layer Type
 */
export type Type36 = 5;
/**
 * An animatable property that holds a float
 */
export type BevelStyle = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Technique = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Strength = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Size3 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Soften = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Use global light
 */
export type GlobalAngle = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Local lighting angle
 */
export type Angle2 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Local lighting altitude
 */
export type Altitude = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type HighlightMode = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a Color
 */
export type HighlightColor = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type HighlightOpacity = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type ShadowMode = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a Color
 */
export type ShadowColor = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type ShadowOpacity = AnimatedProperty & {
  [k: string]: unknown;
};
export type Satin = LayerStyle1 & {
  ty: Type37;
  bm?: BlendMode4;
  c?: Color5;
  o?: Opacity6;
  a?: Angle3;
  d?: Distance2;
  s?: Size4;
  in?: Invert;
  [k: string]: unknown;
};
/**
 * Layer Type
 */
export type Type37 = 6;
/**
 * An animatable property that holds a float
 */
export type BlendMode4 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a Color
 */
export type Color5 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Opacity6 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Angle3 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Distance2 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Size4 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Invert = AnimatedProperty & {
  [k: string]: unknown;
};
export type ColorOverlay = LayerStyle1 & {
  ty: Type38;
  bm?: BlendMode5;
  c?: Color6;
  so?: Opacity7;
  [k: string]: unknown;
};
/**
 * Layer Type
 */
export type Type38 = 7;
/**
 * An animatable property that holds a float
 */
export type BlendMode5 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a Color
 */
export type Color6 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Opacity7 = AnimatedProperty & {
  [k: string]: unknown;
};
export type GradientOverlay = LayerStyle1 & {
  ty: Type39;
  bm?: BlendMode6;
  o?: Opacity8;
  gf?: Gradient;
  gs?: Smoothness;
  a?: Angle4;
  gt?: GradientType;
  re?: Reverse;
  al?: Align;
  s?: Scale1;
  of?: Offset;
  [k: string]: unknown;
};
/**
 * Layer Type
 */
export type Type39 = 8;
/**
 * An animatable property that holds a float
 */
export type BlendMode6 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Opacity8 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds an array of numbers
 */
export type Colors = AnimatedProperty & {
  l?: Length1;
  [k: string]: unknown;
};
/**
 * Number of colors in `k`
 */
export type Count = number;
/**
 * An animatable property that holds a float
 */
export type Smoothness = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Angle4 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Type of a gradient
 */
export type GradientType = GradientType1 & GradientType2;
export type GradientType1 = number;
export type GradientType2 = Linear | Radial;
export type Linear = 1;
export type Radial = 2;
/**
 * An animatable property that holds a float
 */
export type Reverse = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Align with layer
 */
export type Align = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Scale1 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Offset = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Styling effects for this layer
 */
export type LayerStyle = (
  | LayerStroke
  | DropShadow
  | InnerShadow
  | OuterGlow
  | InnerGlow
  | BevelEmboss
  | Satin
  | ColorOverlay
  | GradientOverlay
)[];
/**
 * Layer and shape blend mode
 */
export type BlendMode7 = BlendMode8 & BlendMode9;
export type BlendMode8 = number;
export type BlendMode9 =
  | Normal1
  | Multiply
  | Screen
  | Overlay
  | Darken1
  | Lighten1
  | ColorDodge
  | ColorBurn
  | HardLight
  | SoftLight
  | Difference1
  | Exclusion
  | Hue
  | Saturation
  | Color7
  | Luminosity
  | Add1
  | HardMix;
export type Normal1 = 0;
export type Multiply = 1;
export type Screen = 2;
export type Overlay = 3;
export type Darken1 = 4;
export type Lighten1 = 5;
export type ColorDodge = 6;
export type ColorBurn = 7;
export type HardLight = 8;
export type SoftLight = 9;
export type Difference1 = 10;
export type Exclusion = 11;
export type Hue = 12;
export type Saturation = 13;
export type Color7 = 14;
export type Luminosity = 15;
export type Add1 = 16;
export type HardMix = 17;
/**
 * CSS class used by the SVG renderer
 */
export type CSSClass = string;
/**
 * `id` attribute used by the SVG renderer
 */
export type LayerXMLID = string;
/**
 * tag name used by the SVG renderer
 */
export type LayerXMLTagName = string;
/**
 * This is deprecated in favour of `ct`
 */
export type CollapseTransform = boolean;
/**
 * Marks that transforms should be applied before masks
 */
export type CollapseTransform1 = CollapseTransform2 & CollapseTransform3;
export type CollapseTransform2 = True | False;
export type CollapseTransform3 = 0 | 1;
/**
 * Layer type
 */
export type Type40 = 0;
/**
 * ID of the precomp as specified in the assets
 */
export type ReferenceId = string;
/**
 * Width of the clipping rect
 */
export type Width2 = number;
/**
 * Height of the clipping rect
 */
export type Height2 = number;
/**
 * An animatable property that holds a float
 */
export type TimeRemapping = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Layer with a solid color rectangle
 */
export type SolidColorLayer1 = VisualLayer & {
  ty: Type41;
  sc: Color8;
  sh: Height3;
  sw: Width3;
  [k: string]: unknown;
};
/**
 * Layer type
 */
export type Type41 = 1;
/**
 * Color of the layer, unlike most other places, the color is a `#rrggbb` hex string
 */
export type Color8 = string;
export type Height3 = number;
export type Width3 = number;
/**
 * Layer that shows an image asset
 */
export type ImageLayer1 = VisualLayer & {
  ty: Type42;
  refId: ImageId;
  [k: string]: unknown;
};
/**
 * Layer type
 */
export type Type42 = 2;
/**
 * ID of the image as specified in the assets
 */
export type ImageId = string;
/**
 * Layer with no data, useful to group layers together
 */
export type NullLayer1 = VisualLayer & {
  ty: Type43;
  [k: string]: unknown;
};
/**
 * Layer type
 */
export type Type43 = 3;
/**
 * Layer containing Shapes
 */
export type ShapeLayer1 = VisualLayer & {
  ty: Type44;
  shapes: Shapes;
  [k: string]: unknown;
};
/**
 * Layer type
 */
export type Type44 = 4;
/**
 * Ellipse shape
 */
export type Ellipse = Shape1 & {
  ty: ShapeType3;
  p: Position2;
  s: Size5;
  [k: string]: unknown;
};
/**
 * Drawable shape
 */
export type Shape1 = ShapeElement & {
  d?: Direction;
  [k: string]: unknown;
};
/**
 * Base class for all elements of ShapeLayer and Group
 */
export type ShapeElement = VisualObject & {
  hd?: Hidden1;
  ty: ShapeType;
  bm?: BlendMode10;
  ix?: PropertyIndex3;
  cl?: CSSClass1;
  ln?: LayerXMLID1;
  [k: string]: unknown;
};
/**
 * Whether the shape is hidden
 */
export type Hidden1 = boolean;
export type ShapeType = ShapeType1 & ShapeType2;
export type ShapeType1 =
  | Rectangle
  | Ellipse1
  | PolygonStar
  | Path1
  | Fill
  | Stroke
  | GradientFill
  | GradientStroke
  | NoStyle
  | Group
  | Transform1
  | RoundedCorners
  | PuckerBloat
  | Merge
  | Twist
  | OffsetPath
  | ZigZag
  | Repeater
  | Trim;
export type Rectangle = "rc";
export type Ellipse1 = "el";
export type PolygonStar = "sr";
export type Path1 = "sh";
export type Fill = "fl";
export type Stroke = "st";
export type GradientFill = "gf";
export type GradientStroke = "gs";
export type NoStyle = "no";
export type Group = "gr";
export type Transform1 = "tr";
export type RoundedCorners = "rd";
export type PuckerBloat = "pb";
export type Merge = "mm";
export type Twist = "tw";
export type OffsetPath = "op";
export type ZigZag = "zz";
export type Repeater = "rp";
export type Trim = "tm";
export type ShapeType2 = string;
/**
 * Layer and shape blend mode
 */
export type BlendMode10 = BlendMode11 & BlendMode12;
export type BlendMode11 = number;
export type BlendMode12 =
  | Normal1
  | Multiply
  | Screen
  | Overlay
  | Darken1
  | Lighten1
  | ColorDodge
  | ColorBurn
  | HardLight
  | SoftLight
  | Difference1
  | Exclusion
  | Hue
  | Saturation
  | Color7
  | Luminosity
  | Add1
  | HardMix;
/**
 * Index used in expressions
 */
export type PropertyIndex3 = number;
/**
 * CSS class used by the SVG renderer
 */
export type CSSClass1 = string;
/**
 * `id` attribute used by the SVG renderer
 */
export type LayerXMLID1 = string;
/**
 * Direction the shape is drawn as, mostly relevant when using trim path
 */
export type Direction = Direction1 & Direction2;
export type Direction1 = number;
export type Direction2 = Normal2 | Reversed;
/**
 * Usually clockwise
 */
export type Normal2 = 1;
/**
 * Usually counter clockwise
 */
export type Reversed = 3;
export type ShapeType3 = "el";
/**
 * An animatable property to represent a position in space
 */
export type Position2 = {
  ix?: PropertyIndex;
  a?: Animated;
  x?: Expression;
  l?: Length;
  [k: string]: unknown;
} & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds an array of numbers
 */
export type Size5 = AnimatedProperty & {
  l?: Length1;
  [k: string]: unknown;
};
/**
 * Solid fill color
 */
export type Fill1 = ShapeElement & {
  ty: ShapeType4;
  o: Opacity9;
  c: Color9;
  r?: FillRule;
  [k: string]: unknown;
};
export type ShapeType4 = "fl";
/**
 * Opacity, 100 means fully opaque
 */
export type Opacity9 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a Color
 */
export type Color9 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Rule used to handle multiple shapes rendered with the same fill object
 */
export type FillRule = FillRule1 & FillRule2;
export type FillRule1 = number;
export type FillRule2 = NonZero | EvenOdd;
/**
 * Everything is colored (You can think of this as an OR)
 */
export type NonZero = 1;
/**
 * Colored based on intersections and path direction, can be used to create "holes"
 */
export type EvenOdd = 2;
/**
 * Gradient fill
 */
export type GradientFill1 = ShapeElement &
  Gradient1 & {
    ty: ShapeType5;
    o: Opacity10;
    r?: FillRule3;
    [k: string]: unknown;
  };
export type Gradient1 = {
  s: StartPoint;
  e: EndPoint;
  t?: GradientType3;
  h?: HighlightLength;
  a?: HighlightAngle;
  g: Colors1;
  [k: string]: unknown;
};
/**
 * Starting point for the gradient
 */
export type StartPoint = AnimatedProperty & {
  l?: Length1;
  [k: string]: unknown;
};
/**
 * End point for the gradient
 */
export type EndPoint = AnimatedProperty & {
  l?: Length1;
  [k: string]: unknown;
};
/**
 * Type of the gradient
 */
export type GradientType3 = GradientType4 & GradientType5;
export type GradientType4 = number;
export type GradientType5 = Linear | Radial;
/**
 * Highlight Length, as a percentage between `s` and `e`
 */
export type HighlightLength = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Highlight Angle, relative to the direction from `s` to `e`
 */
export type HighlightAngle = AnimatedProperty & {
  [k: string]: unknown;
};
export type ShapeType5 = "gf";
/**
 * An animatable property that holds a float
 */
export type Opacity10 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Rule used to handle multiple shapes rendered with the same fill object
 */
export type FillRule3 = FillRule4 & FillRule5;
export type FillRule4 = number;
export type FillRule5 = NonZero | EvenOdd;
/**
 * Gradient stroke
 */
export type GradientStroke1 = ShapeElement &
  BaseStroke &
  Gradient1 & {
    ty: ShapeType6;
    [k: string]: unknown;
  };
export type BaseStroke = {
  lc?: LineCap;
  lj?: LineJoin;
  ml?: MiterLimit;
  ml2?: MiterLimit1;
  o: Opacity11;
  w: Width4;
  d?: Dashes;
  [k: string]: unknown;
};
/**
 * Style at the end of a stoked line
 */
export type LineCap = LineCap1 & LineCap2;
export type LineCap1 = number;
export type LineCap2 = Butt | Round | Square;
export type Butt = 1;
export type Round = 2;
export type Square = 3;
/**
 * Style at a sharp corner of a stoked line
 */
export type LineJoin = LineJoin1 & LineJoin2;
export type LineJoin1 = number;
export type LineJoin2 = Miter | Round1 | Bevel;
export type Miter = 1;
export type Round1 = 2;
export type Bevel = 3;
export type MiterLimit = number;
/**
 * Animatable alternative to ml
 */
export type MiterLimit1 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Opacity, 100 means fully opaque
 */
export type Opacity11 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Stroke width
 */
export type Width4 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An item used to described the dashe pattern in a stroked path
 */
export type StrokeDash = VisualObject & {
  n?: DashType;
  v?: Length2;
  [k: string]: unknown;
};
/**
 * Type of a dash item in a stroked line
 */
export type DashType = DashType1 & DashType2;
export type DashType1 = Dash | Gap | Offset1;
export type Dash = "d";
export type Gap = "g";
export type Offset1 = "o";
export type DashType2 = string;
/**
 * Length of the dash
 */
export type Length2 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Dashed line definition
 */
export type Dashes = StrokeDash[];
export type ShapeType6 = "gs";
/**
 * Shape Element that can contain other shapes
 */
export type Group1 = ShapeElement & {
  ty: ShapeType7;
  np?: NumberOfProperties;
  it?: Shapes1;
  cix?: PropertyIndex4;
  [k: string]: unknown;
};
export type ShapeType7 = "gr";
export type NumberOfProperties = number;
/**
 * List of valid shapes
 */
export type Shapes1 = (
  | Ellipse
  | Fill1
  | GradientFill1
  | GradientStroke1
  | Group1
  | Path2
  | PolyStar
  | PuckerBloat1
  | Rectangle1
  | Repeater1
  | RoundedCorners1
  | Stroke1
  | TransformShape
  | Trim1
  | Twist1
  | Merge1
  | OffsetPath1
  | ZigZag1
  | NoStyle1
)[];
/**
 * Index used in expressions
 */
export type PropertyIndex4 = number;
/**
 * Animatable Bezier curve
 */
export type Path2 = Shape1 & {
  ty: ShapeType8;
  ks: Shape2;
  [k: string]: unknown;
};
export type ShapeType8 = "sh";
/**
 * Bezier path
 */
export type Shape2 = {
  ix?: PropertyIndex2;
  a?: Animated6;
  x?: Expression2;
  [k: string]: unknown;
} & {
  [k: string]: unknown;
};
/**
 * Star or regular polygon
 */
export type PolyStar = Shape1 & {
  ty: ShapeType9;
  p: Position3;
  or: OuterRadius;
  os: OuterRoundness;
  r: Rotation1;
  pt: Points;
  sy?: StarType;
  [k: string]: unknown;
} & {
  [k: string]: unknown;
};
export type ShapeType9 = "sr";
/**
 * An animatable property to represent a position in space
 */
export type Position3 = {
  ix?: PropertyIndex;
  a?: Animated;
  x?: Expression;
  l?: Length;
  [k: string]: unknown;
} & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type OuterRadius = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Outer Roundness as a percentage
 */
export type OuterRoundness = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Rotation, clockwise in degrees
 */
export type Rotation1 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Points = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Star type, `1` for Star, `2` for Polygon
 */
export type StarType = StarType1 & StarType2;
export type StarType1 = number;
export type StarType2 = Star | Polygon;
export type Star = 1;
export type Polygon = 2;
/**
 * Interpolates the shape with its center point and bezier tangents with the opposite direction
 */
export type PuckerBloat1 = ShapeElement & {
  ty: ShapeType10;
  a?: Amount;
  [k: string]: unknown;
};
export type ShapeType10 = "pb";
/**
 * Amount as a percentage
 */
export type Amount = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * A simple rectangle shape
 */
export type Rectangle1 = Shape1 & {
  ty: ShapeType11;
  p: Position4;
  s: Size6;
  r: Rounded;
  [k: string]: unknown;
};
export type ShapeType11 = "rc";
/**
 * Center of the rectangle
 */
export type Position4 = {
  ix?: PropertyIndex;
  a?: Animated;
  x?: Expression;
  l?: Length;
  [k: string]: unknown;
} & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds an array of numbers
 */
export type Size6 = AnimatedProperty & {
  l?: Length1;
  [k: string]: unknown;
};
/**
 * Rounded corners radius
 */
export type Rounded = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Duplicates previous shapes in a group
 */
export type Repeater1 = Modifier & {
  ty: ShapeType12;
  c: Copies;
  o?: Offset2;
  m?: Composite;
  tr: Transform2;
  [k: string]: unknown;
};
export type Modifier = ShapeElement;
export type ShapeType12 = "rp";
/**
 * Number of copies
 */
export type Copies = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Offset2 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Stacking order
 */
export type Composite = Composite1 & Composite2;
export type Composite1 = number;
export type Composite2 = Below | Above;
/**
 * Subsequent copies are added underneath the previous ones.
 */
export type Below = 1;
/**
 * Subsequent copies are added on top of the previous ones.
 */
export type Above = 2;
/**
 * Transform applied to each copy
 */
export type Transform2 = Transform3 & {
  so?: StartOpacity;
  eo?: EndOpacity;
  [k: string]: unknown;
};
/**
 * Layer transform
 */
export type Transform3 = {
  a?: AnchorPoint;
  s?: Scale;
  o?: Opacity;
  sk?: Skew;
  sa?: SkewAxis;
  [k: string]: unknown;
} & (
  | (
      | {
          p?: Position;
          [k: string]: unknown;
        }
      | {
          p?: Position1;
          [k: string]: unknown;
        }
    )
  | (
      | {
          r?: Rotation;
          [k: string]: unknown;
        }
      | {
          rx?: XRotation;
          ry?: YRotation;
          rz?: ZRotation;
          or?: Orientation;
          [k: string]: unknown;
        }
    )
);
/**
 * Opacity of the first repeated object.
 */
export type StartOpacity = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Opacity of the last repeated object.
 */
export type EndOpacity = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Rounds corners of other shapes
 */
export type RoundedCorners1 = Modifier & {
  ty: ShapeType13;
  r: Radius;
  [k: string]: unknown;
};
export type ShapeType13 = "rd";
/**
 * An animatable property that holds a float
 */
export type Radius = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Solid stroke
 */
export type Stroke1 = ShapeElement &
  BaseStroke & {
    ty: ShapeType14;
    c: Color10;
    [k: string]: unknown;
  };
export type ShapeType14 = "st";
/**
 * Stroke color
 */
export type Color10 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Group transform
 */
export type TransformShape = ShapeElement &
  Transform3 & {
    ty: ShapeType15;
    [k: string]: unknown;
  };
export type ShapeType15 = "tr";
/**
 * Trims shapes into a segment
 */
export type Trim1 = Modifier & {
  ty: ShapeType16;
  s: Start;
  e: End;
  o: Offset3;
  m?: Multiple;
  [k: string]: unknown;
};
export type ShapeType16 = "tm";
/**
 * Segment start
 */
export type Start = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Segment end
 */
export type End = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Offset3 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * How to treat multiple copies
 */
export type Multiple = Multiple1 & Multiple2;
export type Multiple1 = number;
export type Multiple2 = Simultaneously | Individually;
export type Simultaneously = 1;
export type Individually = 2;
export type Twist1 = ShapeElement & {
  ty: ShapeType17;
  a?: Angle5;
  c?: Center;
  [k: string]: unknown;
};
export type ShapeType17 = "tw";
/**
 * An animatable property that holds a float
 */
export type Angle5 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds an array of numbers
 */
export type Center = AnimatedProperty & {
  l?: Length1;
  [k: string]: unknown;
};
/**
 * Boolean operator on shapes
 */
export type Merge1 = ShapeElement & {
  ty: ShapeType18;
  mm?: MergeMode;
  [k: string]: unknown;
};
export type ShapeType18 = "mm";
/**
 * Boolean operation on shapes
 */
export type MergeMode = MergeMode1 & MergeMode2;
export type MergeMode1 = number;
export type MergeMode2 =
  | Normal3
  | Add2
  | Subtract1
  | Intersect1
  | ExcludeIntersections;
export type Normal3 = 1;
export type Add2 = 2;
export type Subtract1 = 3;
export type Intersect1 = 4;
export type ExcludeIntersections = 5;
/**
 * Interpolates the shape with its center point and bezier tangents with the opposite direction
 */
export type OffsetPath1 = ShapeElement & {
  ty: ShapeType19;
  a?: Amount1;
  lj?: LineJoin3;
  ml?: MiterLimit2;
  [k: string]: unknown;
};
export type ShapeType19 = "op";
/**
 * An animatable property that holds a float
 */
export type Amount1 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Style at a sharp corner of a stoked line
 */
export type LineJoin3 = LineJoin4 & LineJoin5;
export type LineJoin4 = number;
export type LineJoin5 = Miter | Round1 | Bevel;
/**
 * An animatable property that holds a float
 */
export type MiterLimit2 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Changes the edges of affected shapes into a series of peaks and valleys of uniform size
 */
export type ZigZag1 = ShapeElement & {
  ty: ShapeType20;
  r?: Frequency;
  s?: Amplitude;
  pt?: PointType;
  [k: string]: unknown;
};
export type ShapeType20 = "zz";
/**
 * Number of ridges per segment
 */
export type Frequency = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Distance between peaks and troughs
 */
export type Amplitude = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Point type (1 = corner, 2 = smooth)
 */
export type PointType = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Represents a style for shapes without fill or stroke
 */
export type NoStyle1 = ShapeElement & {
  ty: ShapeType21;
  [k: string]: unknown;
};
export type ShapeType21 = "no";
/**
 * List of valid shapes
 */
export type Shapes = (
  | Ellipse
  | Fill1
  | GradientFill1
  | GradientStroke1
  | Group1
  | Path2
  | PolyStar
  | PuckerBloat1
  | Rectangle1
  | Repeater1
  | RoundedCorners1
  | Stroke1
  | TransformShape
  | Trim1
  | Twist1
  | Merge1
  | OffsetPath1
  | ZigZag1
  | NoStyle1
)[];
/**
 * Layer with some text
 */
export type TextLayer1 = VisualLayer & {
  ty: Type45;
  t: Data;
  [k: string]: unknown;
};
/**
 * Layer type
 */
export type Type45 = 5;
/**
 * Contains all the text data and animation
 */
export type Data = {
  a: Ranges;
  d: Document;
  m: Alignment;
  p: FollowPath;
  [k: string]: unknown;
};
export type Name3 = string;
/**
 * Represents boolean values as an integer. 0 is false, 1 is true.
 */
export type Expressible = Expressible1 & Expressible2;
export type Expressible1 = True | False;
export type Expressible2 = 0 | 1;
/**
 * An animatable property that holds a float
 */
export type MaxEase = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type MinEase = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type MaxAmount = AnimatedProperty & {
  [k: string]: unknown;
};
export type BasedOn = BasedOn1 & BasedOn2;
export type BasedOn1 = number;
export type BasedOn2 = Characters | CharacterExcludingSpaces | Words | Lines;
export type Characters = 1;
export type CharacterExcludingSpaces = 2;
export type Words = 3;
export type Lines = 4;
/**
 * Represents boolean values as an integer. 0 is false, 1 is true.
 */
export type Randomize = Randomize1 & Randomize2;
export type Randomize1 = True | False;
export type Randomize2 = 0 | 1;
/**
 * Defines the function used to determine the interpolating factor on a text range selector.
 */
export type Shape3 = Shape4 & Shape5;
export type Shape4 = number;
export type Shape5 = Square1 | RampUp | RampDown | Triangle | Round2 | Smooth;
export type Square1 = 1;
export type RampUp = 2;
export type RampDown = 3;
export type Triangle = 4;
export type Round2 = 5;
export type Smooth = 6;
/**
 * An animatable property that holds a float
 */
export type Offset4 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * Unit type for a text selector
 */
export type RangeUnits = RangeUnits1 & RangeUnits2;
export type RangeUnits1 = number;
export type RangeUnits2 = Percent | Index1;
export type Percent = 1;
export type Index1 = 2;
/**
 * An animatable property that holds a float
 */
export type SelectorSmoothness = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Start1 = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type End1 = AnimatedProperty & {
  [k: string]: unknown;
};
export type Style = Transform3 & {
  sw?: StrokeWidth;
  sc?: StrokeColor;
  sh?: StrokeHue;
  ss?: StrokeSaturation;
  sb?: StrokeBrightness;
  so?: StrokeOpacity;
  fc?: FillColor;
  fh?: FillHue;
  fs?: FillSaturation;
  fb?: FillBrightness;
  fo?: FillOpacity;
  t?: LetterSpacing;
  bl?: Blur;
  ls?: LineSpacing;
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type StrokeWidth = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a Color
 */
export type StrokeColor = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type StrokeHue = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type StrokeSaturation = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type StrokeBrightness = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type StrokeOpacity = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a Color
 */
export type FillColor = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type FillHue = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type FillSaturation = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type FillBrightness = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type FillOpacity = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type LetterSpacing = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type Blur = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type LineSpacing = AnimatedProperty & {
  [k: string]: unknown;
};
export type Ranges = TextRange[];
export type FontFamily = string;
/**
 * Color as a [r, g, b] array with values in [0, 1]
 *
 * @minItems 3
 * @maxItems 4
 */
export type FillColor1 =
  | [number, number, number]
  | [number, number, number, number];
/**
 * Color as a [r, g, b] array with values in [0, 1]
 *
 * @minItems 3
 * @maxItems 4
 */
export type StrokeColor1 =
  | [number, number, number]
  | [number, number, number, number];
export type StrokeWidth1 = number;
/**
 * Render stroke above the fill
 */
export type StrokeOverFill = boolean;
export type FontSize = number;
/**
 * Distance between lines on multiline or wrapped text
 */
export type LineHeight = number;
/**
 * Size of the box containing the text
 *
 * @minItems 2
 * @maxItems 2
 */
export type WrapSize = [number, number];
/**
 * Position of the box containing the text
 *
 * @minItems 2
 * @maxItems 2
 */
export type WrapPosition = [number, number];
/**
 * Text, note that newlines are encoded with \r
 */
export type Text = string;
/**
 * Text alignment / justification
 */
export type Justify = Justify1 & Justify2;
export type Justify1 = number;
export type Justify2 =
  | Left
  | Right
  | Center1
  | JustifyWithLastLineLeft
  | JustifyWithLastLineRight
  | JustifyWithLastLineCenter
  | JustifyWithLastLineFull;
export type Left = 0;
export type Right = 1;
export type Center1 = 2;
export type JustifyWithLastLineLeft = 3;
export type JustifyWithLastLineRight = 4;
export type JustifyWithLastLineCenter = 5;
export type JustifyWithLastLineFull = 6;
export type TextCaps = TextCaps1 & TextCaps2;
export type TextCaps1 = number;
export type TextCaps2 = Regular | AllCaps | SmallCaps;
export type Regular = 0;
export type AllCaps = 1;
export type SmallCaps = 2;
/**
 * Text Tracking
 */
export type Tracking = number;
export type BaselineShift = number;
export type Time = number;
export type Keyframes = TextDocumentKeyframe[];
export type Expression3 = string;
/**
 * One of the ID in the file's slots
 */
export type SlotID2 = string;
export type Alignment = {
  a?: Alignment1;
  g?: Grouping;
  [k: string]: unknown;
};
/**
 * Group alignment
 */
export type Alignment1 = AnimatedProperty & {
  l?: Length1;
  [k: string]: unknown;
};
/**
 * Anchor point grouping
 */
export type Grouping = Grouping1 & Grouping2;
export type Grouping1 = number;
export type Grouping2 = Characters1 | Word | Line | All;
export type Characters1 = 1;
export type Word = 2;
export type Line = 3;
export type All = 4;
/**
 * Uses the path described by a layer mask to put the text on said path.
 */
export type FollowPath = {
  m?: Mask1;
  f?: FirstMargin;
  l?: LastMargin;
  r?: ReversePath;
  a?: ForceAlignment;
  p?: PerpendicularToPath;
  [k: string]: unknown;
};
/**
 * Index of the mask to use
 */
export type Mask1 = number;
/**
 * An animatable property that holds a float
 */
export type FirstMargin = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type LastMargin = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type ReversePath = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type ForceAlignment = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * An animatable property that holds a float
 */
export type PerpendicularToPath = AnimatedProperty & {
  [k: string]: unknown;
};
/**
 * A layer playing sounds
 */
export type AudioLayer1 = Layer & {
  ty: Type46;
  au: AudioSettings;
  refId?: SoundId;
  [k: string]: unknown;
};
/**
 * Layer type
 */
export type Type46 = 6;
export type AudioSettings = {
  lv: Level;
  [k: string]: unknown;
};
/**
 * An animatable property that holds an array of numbers
 */
export type Level = AnimatedProperty & {
  l?: Length1;
  [k: string]: unknown;
};
/**
 * ID of the sound as specified in the assets
 */
export type SoundId = string;
/**
 * 3D Camera
 */
export type CameraLayer = Layer & {
  ty: Type47;
  ks: Transform4;
  pe: Perspective;
  [k: string]: unknown;
};
/**
 * Layer type
 */
export type Type47 = 13;
/**
 * Layer transform
 */
export type Transform4 = {
  a?: AnchorPoint;
  s?: Scale;
  o?: Opacity;
  sk?: Skew;
  sa?: SkewAxis;
  [k: string]: unknown;
} & (
  | (
      | {
          p?: Position;
          [k: string]: unknown;
        }
      | {
          p?: Position1;
          [k: string]: unknown;
        }
    )
  | (
      | {
          r?: Rotation;
          [k: string]: unknown;
        }
      | {
          rx?: XRotation;
          ry?: YRotation;
          rz?: ZRotation;
          or?: Orientation;
          [k: string]: unknown;
        }
    )
);
/**
 * Distance from the Z=0 plane.
 * Small values yield a higher perspective effect.
 */
export type Perspective = AnimatedProperty & {
  [k: string]: unknown;
};
export type DataLayer1 = Layer & {
  ty: Type48;
  refId?: DataSourceId;
  [k: string]: unknown;
};
/**
 * Layer type
 */
export type Type48 = 15;
/**
 * ID of the data source in assets
 */
export type DataSourceId = string;
export type Layers = (
  | PrecompositionLayer
  | SolidColorLayer1
  | ImageLayer1
  | NullLayer1
  | ShapeLayer1
  | TextLayer1
  | AudioLayer1
  | CameraLayer
  | DataLayer1
)[];
/**
 * Framerate in frames per second
 */
export type Framerate1 = number;
/**
 * Extra composition
 */
export type Extra = Extra1 & Extra2;
export type Extra1 = True | False;
export type Extra2 = 0 | 1;
/**
 * External sound
 */
export type Sound = FileAsset;
/**
 * External data source, usually a JSON file
 */
export type DataSource = FileAsset & {
  t: Type49;
  [k: string]: unknown;
};
export type Type49 = 3;
/**
 * List of assets that can be referenced by layers
 */
export type Assets = (Image | Precomposition | Sound | DataSource)[];
/**
 * List of Extra compositions not referenced by anything
 */
export type ExtraCompositions = Precomposition[];
/**
 * List of fonts
 */
export type Fonts = {
  list?: List;
  [k: string]: unknown;
};
/**
 * Describes how a font with given settings should be loaded
 */
export type Font = {
  ascent?: Ascent;
  fFamily: FontFamily1;
  fName: Name4;
  fStyle: FontStyle;
  fPath?: Path3;
  fWeight?: Weight;
  origin?: Origin;
  fClass?: CSSClass2;
  [k: string]: unknown;
};
/**
 * Text will be moved down based on this value
 */
export type Ascent = number;
export type FontFamily1 = string;
/**
 * Name used by text documents to reference this font, usually it's `fFamily` followed by `fStyle`
 */
export type Name4 = string;
export type FontStyle = string;
export type Path3 = string;
export type Weight = string;
export type Origin = Origin1 & Origin2;
export type Origin1 = number;
export type Origin2 = Local | CssUrl | ScriptUrl | FontUrl;
export type Local = 0;
export type CssUrl = 1;
export type ScriptUrl = 2;
export type FontUrl = 3;
/**
 * CSS Class applied to text objects using this font
 */
export type CSSClass2 = string;
export type List = Font[];
export type Character = string;
export type FontFamily2 = string;
export type FontSize1 = number;
export type FontStyle1 = string;
export type Width5 = number;
export type Data1 = CharacterShape | CharacterPrecomp;
/**
 * Shapes forming the character
 */
export type Shapes2 = (
  | Ellipse
  | Fill1
  | GradientFill1
  | GradientStroke1
  | Group1
  | Path2
  | PolyStar
  | PuckerBloat1
  | Rectangle1
  | Repeater1
  | RoundedCorners1
  | Stroke1
  | TransformShape
  | Trim1
  | Twist1
  | Merge1
  | OffsetPath1
  | ZigZag1
  | NoStyle1
)[];
/**
 * ID of the precomp as specified in the assets
 */
export type ReferenceId1 = string;
/**
 * Layer transform
 */
export type Transform5 = {
  a?: AnchorPoint;
  s?: Scale;
  o?: Opacity;
  sk?: Skew;
  sa?: SkewAxis;
  [k: string]: unknown;
} & (
  | (
      | {
          p?: Position;
          [k: string]: unknown;
        }
      | {
          p?: Position1;
          [k: string]: unknown;
        }
    )
  | (
      | {
          r?: Rotation;
          [k: string]: unknown;
        }
      | {
          rx?: XRotation;
          ry?: YRotation;
          rz?: ZRotation;
          or?: Orientation;
          [k: string]: unknown;
        }
    )
);
/**
 * Frame when the layer becomes visible
 */
export type InPoint2 = number;
/**
 * Frame when the layer becomes invisible
 */
export type OutPoint2 = number;
export type TimeStretch1 = number;
export type StartTime1 = number;
/**
 * Data defining text characters as lottie shapes. If present a player might only render characters defined here and nothing else.
 */
export type Characters2 = CharacterData[];
/**
 * Document metadata
 */
export type Metadata =
  | {
      k?: Keywords;
      [k: string]: unknown;
    }
  | {
      k?: Keywords1;
      [k: string]: unknown;
    };
export type Keywords = string[];
export type Keywords1 = string;
export type Filename = string;
export type Comment = string;
export type Time1 = number;
export type Duration = number;
/**
 * Markers defining named sections of the composition.
 */
export type Markers = Marker[];
/**
 * Angle in degrees
 */
export type ShutterAngle = number;
/**
 * Angle in degrees
 */
export type ShutterPhase = number;
export type SamplesPerFrame = number;
export type AdaptiveSampleLimit = number;

/**
 * Base class for layer holders
 */
export interface Composition {
  layers: Layers;
  [k: string]: unknown;
}
/**
 * Position / Translation with split components
 */
export interface Position1 {
  s: Split;
  x: X;
  y: Y;
  z?: Z;
  [k: string]: unknown;
}
export interface EffectNoValue {
  [k: string]: unknown;
}
/**
 * Represents colors and offsets in a gradient
 *
 * Colors are represented as a flat list interleaving offsets and color components in weird ways
 * There are two possible layouts:
 *
 * Without alpha, the colors are a sequence of offset, r, g, b
 *
 * With alpha, same as above but at the end of the list there is a sequence of offset, alpha
 */
export interface Gradient {
  k: Colors;
  p: Count;
  [k: string]: unknown;
}
/**
 * Gradient colors
 */
export interface Colors1 {
  k: Colors;
  p: Count;
  [k: string]: unknown;
}
/**
 * Range of text with custom animations and style
 */
export interface TextRange {
  nm?: Name3;
  s?: Selector;
  a?: Style;
  [k: string]: unknown;
}
export interface Selector {
  t: Expressible;
  xe?: MaxEase;
  ne?: MinEase;
  a: MaxAmount;
  b: BasedOn;
  rn?: Randomize;
  sh: Shape3;
  o?: Offset4;
  r?: RangeUnits;
  sm?: SelectorSmoothness;
  s?: Start1;
  e?: End1;
  [k: string]: unknown;
}
/**
 * Animated property representing the text contents
 */
export interface Document {
  k: Keyframes;
  x?: Expression3;
  sid?: SlotID2;
  [k: string]: unknown;
}
/**
 * A keyframe containing a text document
 */
export interface TextDocumentKeyframe {
  s: Start2;
  t: Time;
  [k: string]: unknown;
}
export interface Start2 {
  f: FontFamily;
  fc: FillColor1;
  sc?: StrokeColor1;
  sw?: StrokeWidth1;
  of?: StrokeOverFill;
  s: FontSize;
  lh?: LineHeight;
  sz?: WrapSize;
  ps?: WrapPosition;
  t: Text;
  j?: Justify;
  ca?: TextCaps;
  tr?: Tracking;
  ls?: BaselineShift;
  [k: string]: unknown;
}
/**
 * Defines character shapes
 */
export interface CharacterData {
  ch: Character;
  fFamily: FontFamily2;
  size: FontSize1;
  style: FontStyle1;
  w: Width5;
  data: Data1;
  [k: string]: unknown;
}
/**
 * Defines a character as shapes
 */
export interface CharacterShape {
  shapes: Shapes2;
  [k: string]: unknown;
}
/**
 * Defines a character as a precomp layer
 */
export interface CharacterPrecomp {
  refId: ReferenceId1;
  ks?: Transform5;
  ip?: InPoint2;
  op?: OutPoint2;
  sr?: TimeStretch1;
  st?: StartTime1;
  [k: string]: unknown;
}
/**
 * User-defined metadata
 */
export interface UserMetadata {
  filename?: Filename;
  customProps?: CustomProperties;
  [k: string]: unknown;
}
export interface CustomProperties {
  [k: string]: unknown;
}
/**
 * Defines named portions of the composition.
 */
export interface Marker {
  cm?: Comment;
  tm?: Time1;
  dr?: Duration;
  [k: string]: unknown;
}
/**
 * Motion blur settings
 */
export interface MotionBlur1 {
  sa?: ShutterAngle;
  sp?: ShutterPhase;
  spf?: SamplesPerFrame;
  asl?: AdaptiveSampleLimit;
  [k: string]: unknown;
}
/**
 * Available property overrides
 */
export interface Slots {
  /**
   * This interface was referenced by `Slots`'s JSON-Schema definition
   * via the `patternProperty` ".*".
   */
  [k: string]: {
    [k: string]: unknown;
  };
}
